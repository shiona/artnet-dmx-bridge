#include "esp_log.h"

#include "driver/uart.h"

static const char *TAG = "DMX task";

const static uart_port_t uart_num = UART_NUM_2;
const DMX_GPIO                    =   GPIO_NUM_17 // pin for dmx tx

static void setup_uart(void)
{
    uart_config_t uart_config = {
        // from https://github.com/luksal/ESP32-DMX/blob/master/src/dmx.cpp
        .baud_rate = 250000,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_2,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };
    // Configure UART parameters
    ESP_ERROR_CHECK(uart_param_config(uart_num, &uart_config));

    // Setup UART buffered IO with event queue
    const int uart_buffer_size = (1024 * 2);
    QueueHandle_t uart_queue;
    // Install UART driver using an event queue here
    ESP_ERROR_CHECK(uart_driver_install(UART_NUM_2, uart_buffer_size, \
                                            uart_buffer_size, 10, &uart_queue, 0));
}

static uint8_t dmx_buffer[513] = { 0 }; // first byte has to always be 0,
                                        // rest are the 512 channels 1-512
static size_t dmx_transmit_size = 513;

static void dmx_worker(void *bogus_param)
{
    setup_uart();

    while(true) {
        dmx_buffer[101]++; // Overeflow ok
        uart_write_bytes_with_break(uart_num, dmx_buffer, dmx_transmit_size , 100);
        ESP_LOGI(TAG, "sending: %d", dmx_buffer[101]);
    }
}

#define STACK_SIZE 2000
static StaticTask_t xTaskBuffer;
static StackType_t xStack[ STACK_SIZE ];
static TaskHandle_t task_handle = NULL;

void dmx_task_start(void)
{
    task_handle = xTaskCreateStatic(
                  dmx_worker,
                  "DMX worker",
                  STACK_SIZE,
                  ( void * ) 0,
                  tskIDLE_PRIORITY,
                  xStack,
                  &xTaskBuffer );
}
